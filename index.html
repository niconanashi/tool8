<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>ニコ生CMメーカー 制作ツール (正常動作版)</title>

	<!-- セキュリティ規制回避 -->
	<script>
		if ('serviceWorker' in navigator) {
			navigator.serviceWorker.register('./coi-serviceworker.js', { scope: './' });
		}
	</script>
	<script src="coi-serviceworker.js"></script>

	<!-- 必須ライブラリ -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
	<!-- FFmpeg v0.11 -->
	<script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>

	<style>
		body { font-family: sans-serif; background-color: #f0f4f8; padding: 20px; display: flex; flex-direction: column; align-items: center; }
		.card { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); width: 100%; max-width: 900px; }
		h1 { font-size: 26px; color: #2d3748; display: flex; align-items: center; justify-content: center; gap: 15px; margin: 0 0 20px 0; }
		.title-icon { width: 60px; height: 60px; object-fit: contain; }
		.controls { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; background: #edf2f7; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
		.input-group { display: flex; flex-direction: column; gap: 5px; font-size: 13px; }
		input { padding: 6px; border: 1px solid #cbd5e0; border-radius: 4px; }
		.audio-section { background: #fffaf0; border: 2px dashed #ed8936; border-radius: 8px; padding: 15px; margin-bottom: 20px; text-align: center; }
		#audio-drop-zone { padding: 15px; cursor: pointer; color: #7b341e; font-weight: bold; }
		#audio-status { font-size: 12px; margin-top: 5px; color: #c05621; }
		.image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin: 20px 0; border: 1px solid #eee; padding: 15px; min-height: 150px; background: #fdfdfd; }
		.image-item { position: relative; background: #fff; border: 2px solid #cbd5e0; border-radius: 8px; padding: 5px; cursor: grab; text-align: center; }
		.image-item img { width: 100%; height: 85px; object-fit: contain; background: #333; border-radius: 4px; }
		.image-label { font-size: 11px; margin-top: 5px; font-weight: bold; color: #4a5568; }
		.btn-del { position: absolute; top: -8px; right: -8px; background: #e53e3e; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-weight: bold; z-index: 10; }
		.btn-add { background: #3182ce; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: bold; margin-bottom: 10px; }
		#downloadZip { background: #48bb78; color: white; border: none; padding: 15px; border-radius: 8px; width: 100%; font-size: 18px; font-weight: bold; cursor: pointer; margin-top: 20px; }
		#status { margin: 15px 0; color: #2b6cb0; font-weight: bold; text-align: center; }
	</style>
</head>
<body>

<div class="card">
	<h1><img src="icon.png" alt="icon" class="title-icon">ニコ生CMメーカー 制作ツール</h1>
	
	<div class="controls">
		<div class="input-group"><label>全体の再生時間(秒)</label><input type="number" id="totalDuration" value="90"></div>
		<div class="input-group"><label>フェードイン速度</label><input type="number" id="fadeIn" value="0.02" step="0.01"></div>
		<div class="input-group"><label>終了メッセージ</label><input type="text" id="endText" value="ご視聴ありがとうございました"></div>
		<div class="input-group"><label>メッセージ色</label><input type="color" id="textColor" value="#ffffff"></div>
	</div>

	<div class="audio-section">
		<div id="audio-drop-zone">ここにBGMをドロップ</div>
		<input type="file" id="audio-input" style="display:none" accept="audio/*">
		<div id="audio-status">音声未設定：既存のBGMを使用</div>
	</div>

	<div style="text-align: center;">
		<button class="btn-add" onclick="document.getElementById('bulk-input').click()">画像を追加</button>
		<input type="file" id="bulk-input" style="display:none" multiple accept="image/*">
	</div>

	<div id="image-grid" class="image-grid"></div>
	<div id="status">準備中...</div>
	<button id="downloadZip">game.zip を作成・ダウンロード</button>
</div>

<input type="file" id="replace-input" style="display:none" accept="image/*">

<script>
	const { createFFmpeg, fetchFile } = FFmpeg;
	const gridEl = document.getElementById('image-grid');
	const status = document.getElementById('status');
	const audioStatus = document.getElementById('audio-status');
	const downloadBtn = document.getElementById('downloadZip');
	const replaceInput = document.getElementById('replace-input');

	let imageList = []; 
	let replaceTargetId = null;
	let convertedBgm = { m4a: null, ogg: null };

	const ffmpeg = createFFmpeg({
		log: false,
		corePath: 'https://unpkg.com/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js'
	});

	(async () => {
		try {
			await ffmpeg.load();
			const letters = "abcdefghijklmnopqrst".split("");
			for (const char of letters) {
				try {
					const res = await fetch(`./game/files/${char}.png`);
					if (res.ok) addImageToList(await res.blob());
				} catch (e) {}
			}
			status.innerText = "準備完了";
		} catch (e) { status.innerText = "エラー: FFmpegのロード失敗"; }
	})();

	function addImageToList(blob) {
		const item = { id: Math.random(), blob: blob, url: URL.createObjectURL(blob) };
		imageList.push(item);
		const div = document.createElement('div');
		div.className = 'image-item';
		div.dataset.id = item.id;
		div.innerHTML = `<button class="btn-del" onclick="deleteImage(${item.id})">×</button>
			<img src="${item.url}" onclick="triggerReplace(${item.id})"><div class="image-label"></div>`;
		gridEl.appendChild(div);
		updateLabels();
	}

	function updateLabels() {
		gridEl.querySelectorAll('.image-label').forEach((el, i) => el.innerText = `${i + 1}枚目`);
	}

	Sortable.create(gridEl, {
		animation: 150,
		onEnd: () => {
			const newOrder = [];
			gridEl.querySelectorAll('.image-item').forEach(el => {
				newOrder.push(imageList.find(img => img.id === parseFloat(el.dataset.id)));
			});
			imageList = newOrder;
			updateLabels();
		}
	});

	function deleteImage(id) {
		imageList = imageList.filter(img => img.id !== id);
		gridEl.querySelector(`[data-id="${id}"]`).remove();
		updateLabels();
	}

	function triggerReplace(id) { replaceTargetId = id; replaceInput.click(); }
	replaceInput.onchange = (e) => {
		const file = e.target.files[0];
		if (!file) return;
		const idx = imageList.findIndex(img => img.id === replaceTargetId);
		imageList[idx].blob = file;
		imageList[idx].url = URL.createObjectURL(file);
		gridEl.querySelector(`[data-id="${replaceTargetId}"] img`).src = imageList[idx].url;
	};

	document.getElementById('bulk-input').onchange = (e) => {
		Array.from(e.target.files).forEach(file => addImageToList(file));
	};

	const audioDropZone = document.getElementById('audio-drop-zone');
	audioDropZone.onclick = () => document.getElementById('audio-input').click();
	document.getElementById('audio-input').onchange = (e) => { if(e.target.files[0]) processAudio(e.target.files[0]); };
	audioDropZone.ondragover = (e) => { e.preventDefault(); };
	audioDropZone.ondrop = async (e) => {
		e.preventDefault();
		if (e.dataTransfer.files[0]) processAudio(e.dataTransfer.files[0]);
	};

	async function processAudio(file) {
		audioStatus.innerText = "変換中...";
		try {
			ffmpeg.FS('writeFile', 'src', await fetchFile(file));
			await ffmpeg.run('-i', 'src', '-c:a', 'aac', '-b:a', '128k', '-movflags', '+faststart', 'out.m4a');
			convertedBgm.m4a = ffmpeg.FS('readFile', 'out.m4a');
			await ffmpeg.run('-i', 'src', '-c:a', 'libvorbis', '-q:a', '4', 'out.ogg');
			convertedBgm.ogg = ffmpeg.FS('readFile', 'out.ogg');
			const audioTag = document.createElement('audio');
			audioTag.src = URL.createObjectURL(file);
			audioTag.onloadedmetadata = () => {
				document.getElementById('totalDuration').value = Math.ceil(audioTag.duration);
				audioStatus.innerText = `設定完了: ${file.name}`;
			};
		} catch (err) { audioStatus.innerText = "変換失敗"; }
	}

	downloadBtn.onclick = async () => {
		if (imageList.length === 0) return;
		status.innerText = "作成中...";
		const zip = new JSZip();
		const durationMs = parseInt(document.getElementById('totalDuration').value) * 1000;
		const imageIds = imageList.map((_, i) => String.fromCharCode(97 + i));

		// --- 1. game.json 作成 (完全再現版) ---
		const gameJson = {
			"width": 1280,
			"height": 720,
			"fps": 30,
			"main": "./script/main.js",
			"assets": {
				"bgm": {
					"type": "audio", "path": "files/bgm", "systemId": "sound", "duration": durationMs,
					"hint": { "extensions": [ ".m4a", ".ogg" ] },
					"virtualPath": "audio/bgm"
				}
			},
			"defaultSkippingScene": "indicator",
			"defaultLoadingScene": "none",
			"environment": {
				"sandbox-runtime": "3",
				"nicolive": {
					"supportedModes": [ "ranking" ],
					"preferredSessionParameters": { "totalTimeLimit": 200 }
				},
				"external": { "send": "0" },
				"akashic-runtime": { "version": "~3.12.6-1", "flavor": "-canvas" }
			},
			"globalScripts": [],
			"moduleMainScripts": {},
			"exportZipInfo": {
				"version": "2.0.6",
				"option": { "strip": true, "babel": true, "hashFilename": true, "targetService": "nicolive", "nicolive": true }
			},
			"assetBundle": "./script/aez_asset_bundle.js"
		};

		imageIds.forEach(id => {
			gameJson.assets[id] = {
				"type": "image", "path": `files/${id}.png`, "width": 1280, "height": 720,
				"hint": { "untainted": true }, "virtualPath": `image/${id}.png`
			};
		});

		gameJson.assets["aez_asset_bundle"] = {
			"type": "script", "global": true, "path": "files/main.js", "virtualPath": "script/aez_asset_bundle.js"
		};

		zip.file("game.json", JSON.stringify(gameJson, null, "\t"));

		// --- 2. main.js 生成 (元のコードを完全復元) ---
		const endTextVal = document.getElementById('endText').value.replace(/"/g, '\\"');
		const textColorVal = document.getElementById('textColor').value;
		const fadeSpeed = document.getElementById('fadeIn').value;

		const mainJsContent = `module.exports={assets:{"main": {type:"script",path:"script/main.js",global:true,execute: rv => {
'use strict';
const module = rv.module;const exports = module.exports;const require = module.require;const __dirname = rv.dirname;const __filename = rv.filename;
function main(param) {
  var TOTAL_MUSIC_DURATION = ${durationMs};
  var MAX_IMAGES = ${imageList.length};
  var FADE_SPEED = ${fadeSpeed};
  var FADE_SPEED2 = 0.1;
  var IMAGE_IDS = ${JSON.stringify(imageIds)};

  var timePerImage = TOTAL_MUSIC_DURATION / MAX_IMAGES;
  var fps = 30;
  var fadeTimeMs = 1 / FADE_SPEED * (1000 / fps);
  var calculatedDuration = timePerImage - fadeTimeMs;
  if (calculatedDuration < 0) calculatedDuration = 0;
  g.game.audio.music.volume = 0.9;

  var scene = new g.Scene({ game: g.game, assetPaths: ["/**/*"] });
  var font = new g.DynamicFont({
    game: g.game, fontFamily: "sans-serif", fontColor: "${textColorVal}",
    strokeColor: "black", strokeWidth: 5, size: 60
  });

  scene.onLoad.add(function () {
    if (scene.asset.getAudioById("bgm")) scene.asset.getAudioById("bgm").play();
    var currentIndex = 0; var currentSprite = null;

    function showNextSlide() {
      if (currentIndex >= MAX_IMAGES || currentIndex >= IMAGE_IDS.length) {
        new g.Label({
          scene: scene, font: font, text: "${endTextVal}",
          x: g.game.width / 2, y: g.game.height / 2,
          anchorX: 0.5, anchorY: 0.5, fontSize: 60, parent: scene
        });
        return;
      }
      var nextSprite = new g.Sprite({
        scene: scene, src: scene.asset.getImageById(IMAGE_IDS[currentIndex]),
        opacity: currentIndex === 0 ? 1 : 0, parent: scene
      });
      if (currentIndex === 0) {
        currentSprite = nextSprite;
        startTimer(timePerImage);
      } else {
        var prevSprite = currentSprite;
        nextSprite.onUpdate.add(function () {
          if (nextSprite.opacity < 1) {
            nextSprite.opacity += FADE_SPEED;
            if (nextSprite.opacity > 1) nextSprite.opacity = 1;
            nextSprite.modified();
          } else {
            nextSprite.onUpdate.removeAll();
            prevSprite.onUpdate.add(function () {
              prevSprite.opacity -= FADE_SPEED2;
              if (prevSprite.opacity <= 0) prevSprite.destroy(); else prevSprite.modified();
            });
            currentSprite = nextSprite;
            startTimer(calculatedDuration);
          }
        });
      }
    }
    function startTimer(duration) {
      scene.setTimeout(function () { currentIndex++; showNextSlide(); }, duration);
    }
    showNextSlide();
  });
  g.game.pushScene(scene);
}
module.exports = main;
return module.exports;
},},"data": {type:"text",path:"text/data.json",data: \`{}\`,},}}`;

		zip.file("files/main.js", mainJsContent);

		// --- 3. 音声ファイル追加 ---
		if (convertedBgm.m4a) {
			zip.file("files/bgm.m4a", convertedBgm.m4a);
			zip.file("files/bgm.ogg", convertedBgm.ogg);
		} else {
			try {
				const [bA, bO] = await Promise.all([fetch('./game/files/bgm.m4a').then(r=>r.blob()), fetch('./game/files/bgm.ogg').then(r=>r.blob())]);
				zip.file("files/bgm.m4a", bA); zip.file("files/bgm.ogg", bO);
			} catch(e){}
		}

		// --- 4. 画像ファイル追加 ---
		imageList.forEach((img, i) => zip.file(`files/${imageIds[i]}.png`, img.blob));

		saveAs(await zip.generateAsync({ type: "blob" }), "game.zip");
		status.innerText = "作成完了！";
	};
</script>
</body>
</html>
